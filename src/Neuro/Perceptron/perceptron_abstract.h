#ifndef SRC_PERCEPTRON_PERCEPTRON_ABSTRACT_H_
#define SRC_PERCEPTRON_PERCEPTRON_ABSTRACT_H_

#include "../Matrix/neuron_matrix.h"

typedef struct analytical_data {
/** СТРУКТУРА С АНАЛИТИЧЕСКИМИ ДАННЫМИ\n
 *
 * average_accuracy - средняя точность предсказаний по выборке\n\n
 *
 * precision - количество объектов, которые сеть указала как положительные и была права\n\n
 *
 * recall - показывает, какую долю объектов положительного класса
 * из всех объектов положительного класса нашел алгоритм.\n\n
 *
 * f_measure - объединение precision и recall в агрегированный
 * критерий качества (среднее гармоническое precision и recall)\n\n
 *
 * time - затраченное на тестирование время\n\n
 */
  double average_accuracy;
  double precision;
  double recall;
  double f_measure;
  double time;
} analytical_data;

class Perceptron {
  /**
   * АБСТРАКТНЫЙ КЛАСС Perceptron.
   * Под методы данного класс реализовано UI в QT.\n
   * В проект реализовано две структуры. Матричная и графовая.
   */
 public:
  /** МЕТОД learn. Функция обучает нейросеть, и возвращает график с изменением ошибки во время обучения
   * принимает путь к данным в формате .csv\n
   * Нейросеть спроектирована так что данные в базе должны быть значения int, записанные через запятую.
   * одна строчка - это один кейс\n
   *
   * @param in_path путь к файлу с обучающим материалом
   * @param in_epochs количество эпох обучения по умолчанию одна
   * @return  Пара необходимая для построения выходного графика.\n
   * first - количество эпох.\n
   * second - вектор со средней ошибкой на каждый кейс обучения.\n То есть если учить 2 эпохи по 88.000 элементов
   * функция должна вернуть пару где первый элемент равен 2,
   * а второй - это вектор из 176.000 элементов средних ошибок на каждый кейс
   */
  virtual auto learn(const std::string &in_path, int in_epochs) -> std::pair<int, std::vector<double>> = 0;

  /** МЕТОД test. Тестирует эффективность нейросети.
   * Задействует только back-propagation и формирует аналитический отчет.
   *
   * @param in_path путь к файлу с тестовым материалом
   *
   * @param in_data_part значение в диапазоне от 0.0 до 1.0.
   * какую часть тестов прогонять 0.0 нулевая выборка, 1.0 - полная выборка.
   *
   * @return структура с заполненными аналитическими данными analytical_data описано отдельно сверху
   */
  virtual auto test(const std::string &in_path, double in_data_part) -> analytical_data = 0;

  /** МЕТОД predict. Принимает нейроны входного слоя(в виде матрицы) и выполняет разовое предсказание,
   * в соответствии с весами и возвращает номер нейрона выходного слоя, не изменяет веса.
   *
   * @param in_layer принимает NeuronMatrix, матрицу со значениями входного слоя. Матрица вида 1x784
   * @return возвращает порядковый номер предсказанной буквы от 1 до 26
   */
  virtual auto predict(const NeuronMatrix &in_layer) -> int = 0;

  /** МЕТОД exportDataBase. Выгружает веса в определенном виде. Образец для хранения данных следующий:\n
   * 2\n
   * 768 128\n
   * d a t a ....\n
   * 128 26\n
   * d a t a ....\n\n
   *
   * 2 - первая строчка только количество внутренних слоев одной цифрой от 1 до 5\n
   *
   * 768 128 - дальше пошли цифры с количествами нейронов на слоях веса между которыми мы сохраняем,
   * в моем случае это марицы весов, в графовом методе - это веса в графах.\n
   *
   * d a t a .... - дальше сами данные в одну строчку без переносов строки с этого слоя(!) все данные через пробел
   * данные идут подряд одной  "колбаской". Сначала все веса первого нейрона первого слоя,
   * потом все веса второго нейрона и тд все слои\n
   *
   * дальше по аналогии\n
   * 128 26\n
   * d a t a ....\n
   * Таких пар строк столько же сколько и слоев. Файл при экспорте должен открываться как бинарный .bin
   *
   * @param in_path абсолютный путь куда экспортировать данные
   *
   */
  virtual auto exportDataBase(const std::string &in_path) -> void = 0;

  /** МЕТОД exportDataBase. Подгружает веса из базы данных в определенном виде, аналогичном как в методе importDataBase.
   *
   * @param in_path абсолютный путь куда импортировать данные
   */
  virtual auto importDataBase(const std::string &in_path) -> void= 0;

  virtual ~Perceptron() = default;;
};

#endif // SRC_PERCEPTRON_PERCEPTRON_ABSTRACT_H_
